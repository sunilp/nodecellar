<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>javascript - The Practitioner Part</title>

		<meta name="description" content="A presentation to show the ease of usage of Javascript">
		<meta name="author" content="Sunil Prakash">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

       <script src="lib/js/jquery-1.10.2.min.js"></script>
       <script src="lib/js/underscore-min.js"></script>
       <script src="lib/js/backbone-min.js"></script>


		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Javascript </h1>
					 <h2>Concepts </h2>
					<h3>Easy to Advance</h3>
					<p>
						<small>Created by <a href="http://sprakas.com">Sunil Prakash</a> / <a href="http://twitter.com/_sunilp">@_sunilp</a></small>
					</p>
				</section>

				 <section data-markdown>
                    <script type="text/template">
                        ### Javascript - Basics
                                              
                        * Functions
                        * as Expression or Literals
                        * Invocation Patterns
                        * Augumenting Function Types
                        * Recursion
                        * Cascading
                        * Callbacks
                        * Currying
                        * Memorization
                    </script>
                </section>
				
				 <section data-markdown>
                    <script type="text/template">
                        ## Functions
                         Functions are first Class Objects in JavaScript. 
						
					function addNumbers(num1,num2){
							           return num1+num2 ;
							 }
                        
                         Objects are collections of name/value pairs having a hidden link to a prototype object
        				 
        			function Greeter() {}
        					Greeter.prototype.message = "Happy Diwali";
        					Greeter.prototype.greet = function(){
        						return "Hi " + this.message;
        					}
                    </script>
                </section>
				
				
				 <section data-markdown>
                    <script type="text/template">
                        ## Declaring Function
                         Named Function and Anonymous. 
						
					function product(num1,num2){
							      return num1 * num2 ;
							 }
                        
                         Function Literals - Functions as Expression
        				 
        			var productOfNumber = function(num1, num2){
						return num1 * num2;
					}
                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Function Invocation
		
						function sayHello(name){
							console.log("Hello "+ name);
						}
                           
                          * with paranthesis ()
			sayHello('prakash');                        
                          * with apply
			 sayHello.apply(null,['prakash']);                           
                          * with call
			 sayHello.call(null,'prakash');           
                         
						 
					
                        *this* and *arguments* parameters are available with each function   
                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Augmenting Type
                         JavaScript allows the basic types of the language to be augmented.

                         For example, by augmenting Function.prototype, we can make a method available to all functions 
                         
					Function.prototype.method = function (name, func) {
						this.prototype[name] = func;
						return this;
					};
                        By augmenting *Function.prototype* with a method method, we no longer have to type the name of the prototype property

                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Resursion
                         A recursive function is a function that calls itself, either directly or indirectly.
                         
                         
					function factorial(num){
						if (num === 0)
							{ return 1; }
						else
							{ return num * factorial( num - 1 ); }
					}
                        Problem is divided into a set of similar subproblems, each solved with a trivial solution

                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Cascading or Chaning
                         Methods with return this instead of undefined, we can enable cascades.
                         
                         
						 
					$("#p1").css("color","red")
						.slideUp(2000)
						.slideDown(2000);
						
                        Most of the libraries supports this like jQuery.

                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Callbacks
                         Functions which can be called asyncroniously.Called back.
                         
						 
					function mainCall(param1, param2, callback) {  
						console.log('Executing: ' + param1 + ', ' + param2);  
						callback();  
					}  
      
					mainCall('hello', 'javascript', function() {  
						console.log('this will be executed');  
					});  


                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Currying
                         Calling Functions Partially.
                         
						 
					
					function add(x, y) {
						if (typeof y === "undefined") { // partial
							return function (y) {
								return x + y;
							};
						}
						return x + y;
					}

					var addWith5 = add(5);

					addWith5(20); //25
					addWith5(35); //40
					add(10)(5); // 15  

                        Currying allows us to produce a new function by combining a function and an argument
                    </script>
                </section>
				
				<section data-markdown>
                    <script type="text/template">
                        ## Memorization
                         Caching the result for faster performance.
                         
						 
					Function.prototype.memoize = function(){
						var self = this, cache = {};
						return function( arg ){
							if(arg in cache) {
								console.log('Cache hit for '+arg);
								return cache[arg];
							} else {
								console.log('Cache miss for '+arg);
								return cache[arg] = self( arg );
							}
						}
					}  

                        Could be used to cache server response, may be time consuming ajax calls. 
                    </script>
                </section>
				
				
				
				

				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h2>Closure</h2>
						<p>
							Whenever you see the function keyword within another function , you are creating a closure. the inner function has access to variables in the outer function.
						</p>
						<pre><code data-trim contenteditable style="font-size: 18px; margin-top: 20px;">
						function foo(x) {
						  var tmp = 3;
						  return function (y) {
							alert(x + y + (++tmp));
						  }
						}
						var bar = foo(2); // bar is now a closure.
						bar(10);
						
						</code></pre>
						<p> <small>
						The above function will also alert 16, because bar can still refer to x and tmp, even though it is no longer directly inside the scope.
						</small></p>
					</section>
					<section>
						<h2>IIFE</h2>
						<p>Immediately Invoked  Function Expression</p>
						
						<pre><code>
						(function(){
							  //...
							 })();
						</code></pre>
						
						<pre><code>
						(function($){
							    $.fn.myPlugin = function(){
								//...
								}
							 })(jQuery);
						</code></pre>
						
						<p>
						 <small> 
						 <ul>
						 <li> produces a lexical scope using JavaScript's function scoping. </li>
						 <li> avoid variable hoisting from within blocks, </li>
						 <li> protect against polluting the global environment and simultaneously allow public access to methods while retaining privacy for variables defined within the function. </li>
						 </ul>
						
						 </small>
						</p>
					</section>
					<section>
						<h2>Closures</h2>
						<h3>How it works?</h3>
						
						<pre><code contenteditable style="width:120%">
						//         ____________Immediately executed (self invoked)___________________  
						//         |                                                                |  
						//         |      Scope Retained for use        __Returned as the______     |  
						//         |     only by returned function     |  value of func       |     |  
						//         |             |            |        |                      |     |  
						//         v             v            v        v                      v     v  
						var func = (function() { var a = 'val'; return function() { alert(a); }; })(); 
						</code></pre>
						
						<ul>
						<li> The local variables for a function - kept alive after the function has returned, or </li>
						<li> Closure is a stack-frame which is not deallocated when the function returns (as if a 'stack-frame' were malloc'ed instead of being on the stack!).</li>
						<li> Scope is at the function level, not the block level</li>
						</ul>
						
					</section>
					<section>
						<h2>private methods with closures</h2>
						<p>JavaScript does not have private methods, but it is possible to emulate private methods using closures</p>
						
						<pre><code data-trim contenteditable>
					 var Counter = (function() {
						var privateCounter = 0;
						function changeBy(val) {
						     privateCounter += val;
						}
						return {
						    increment: function() {
						        changeBy(1);
						    },
						    decrement: function() {
						        changeBy(-1);
						    },
						    value: function() {
						        return privateCounter;
						    }
						  };   
						})();

				alert(Counter.value()); /* Alerts 0 */
				Counter.increment();
				Counter.increment();
				alert(Counter.value()); /* Alerts 2 */
				Counter.decrement();
				alert(Counter.value()); /* Alerts 1 */
						</code></pre>
					</section>
					
				</section>

				<section>
					<h2>OOPS</h2>
					<p> Abstraction </p>
					<p> Polymorphism </p>
					<p> Encapsulation </p>
					<p> Private and Public variable </p>
				</section>

			<section>	
				<section>
					<h2> Namespaces</h2>
					<p> A way to avoid collisions with other objects or variables in the global namespace. </p>
					<pre><code>
					var myApp =  myApp || {};
					// perform a similar existence check when defining nested
					// children
					myApp.routers = myApp.routers || {};
					myApp.model = myApp.model || {};
					myApp.model.special = myApp.model.special || {};
					</code></pre>
					<p>
						Larger codebases requiring both namespaces and deep sub-namespaces require a succinct solution that promotes readability and scales
					</p>
				</section>
				
				<section>
					<h2> Single global variables </h2>
					<p>  Opting for a single global variable as your primary object of reference. </p>
					<pre><code>
					var myApplication =  (function(){
						    function methodA(){
						       /*...*/
						    }
						    return{
						       /*...*/
						    }
					})();
					</code></pre>
					<p>
						Confusion occurs, when other can accidently have the same variable name defined in global scope.
					</p>
				</section>
				<section>
					<h2> Object literal notation </h2>
					<p>  Object containing a collection of key:value pairs with a colon separating each pair of keys and values. </p>
					<pre><code>
					var myApplication = {
					    getInfo:function(){ 
					    },
					    // we can also populate our object literal to support
					    // further object literal namespaces containing anything
					    // really:
					    models : {},
					    views : {
					        pages : {}
					    },
					    collections : {}
					};
					</code></pre>
					<p>
						Refer this <a href="http://rmurphey.com/blog/2009/10/15/using-objects-to-organize-your-code/">link</a> for more details.
					</p>
				</section>
				
				<section>
					<h2> Namespace injection </h2>
					<p> Injection the methods and properties for a specific namespace from within a function wrapper using this as a namespace proxy. </p>
					<pre><code>
					var myApp = myApp || {};
					    myApp.utils =  {};
					    
					    (function() {
					        var val = 5;
					        this.getValue = function() {
					             return val;
					        };
					        this.setValue = function(newVal) {
					             val = newVal;
					        }
					        // also introduce a new sub-namespace
					        this.tools = {};
					    }).apply(myApp.utils);
						
					    // inject new behaviour into the tools namespace
					    // which we defined via the utilities module
					    (function(){
					         this.diagnose = function(){
					             return 'diagnosis';
					        }
					    }).apply(myApp.utils.tools);
						
						console.log(myApp); //the now populated namespace
						console.log(myApp.utils.getValue()); // test get
						myApp.utils.setValue(25); // test set
						console.log(myApp.utils.getValue());
						console.log(myApp.utils.tools.diagnose());
					</code></pre>
					
				</section>
			</section>	
			
				
				<section>
					<section data-markdown>
                    <script type="text/template">
                        ## Design Patterns
                        Some useful Patterns - Mostly used

                        * Creational Pattern
                        * Constructor Pattern
                        * Singleton Pattern
                        * Module Pattern
                        * Observer Pattern
                        * Prototype Pattern
                        * Command Pattern
                        * Facade Pattern
                        * Decorator Pattern

                    </script>
                	</section>


                <section>
					<h2> Creational Pattern  </h2>
					<p> In JavaScript, the three common ways to create new objects are as follows. </p>
					<pre><code data-trim contenteditable>
					// Each of the following options will create a new empty object:
						var newObject = {}; // or
						var newObject = Object.create(null); // or
						var newObject = new Object();
					</code></pre>
					
				   </section>

				</section>

				   <section>
					<h2> Unit Testing  </h2>
					<h3>  Jasmine </h3>
					<pre><code data-trim contenteditable>
describe("General Test", function(){

	it("should exist", function(){

	 var f = new MyApp.myFun();
	 
	 console.log(MyApp.myFun.n2);
	  
	  expect(MyApp.myFun.n2).toEqual(56);
	  
	  expect(f.n1).toBe(5);

	});


});
					</code></pre>
					<p> Jasmine is a behavior-driven development framework for testing JavaScript code.</p>
				   </section>

				   <section>
				   	<h3> Jasmine Matchers </h3>
<pre><code data-trim contenteditable style="margin-left:-100px;width:140%;">
//Jasmine has several built-in matchers. Here are a few:

    expect(x).toEqual(y); //compares objects or primitives x and y and passes if they are equivalent

    expect(x).toBe(y); //compares objects or primitives x and y and passes if they are the same object

    expect(x).toMatch(pattern); //compares x to string or regular expression pattern and passes if they match

    expect(x).toBeDefined(); //passes if x is not undefined

    expect(x).toBeUndefined(); //passes if x is undefined

    expect(x).toBeNull(); //passes if x is null

    expect(x).toBeTruthy(); //passes if x evaluates to true

    expect(x).toBeFalsy(); //passes if x evaluates to false

    expect(x).toContain(y); //passes if array or string x contains y

    expect(x).toBeLessThan(y); //passes if x is less than y

    expect(x).toBeGreaterThan(y); //passes if x is greater than y

    expect(function(){fn();}).toThrow(e); //passes if function fn throws exception e when executed
/*
The old matchers toNotEqual, toNotBe, toNotMatch, and toNotContain have been deprecated and will be removed in a future release. Please change your specs to use not.toEqual, not.toBe, not.toMatch, and not.toContain respectively.
*/

//Every matcher's criteria can be inverted by prepending .not:

    expect(x).not.toEqual(y); compares objects or primitives x and y and passes if they are not equivalent

</code></pre>

</section>

				<section>
					<h1>THE END</h1>
					<h3>Thank You</h3>
					<p>By Sunil Prakash</p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
